// Code generated by protoc-gen-go. DO NOT EDIT.
// source: v1/Service.proto

package v1

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("v1/Service.proto", fileDescriptor_85f51ec2aaeb527c) }

var fileDescriptor_85f51ec2aaeb527c = []byte{
	// 514 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x92, 0xd1, 0x6e, 0x12, 0x41,
	0x14, 0x86, 0x0b, 0x54, 0x53, 0x0f, 0xc5, 0x92, 0x51, 0xd1, 0xd0, 0xc6, 0x28, 0x57, 0x7a, 0x33,
	0xb8, 0x18, 0x93, 0xaa, 0x69, 0x22, 0xa5, 0x24, 0x9a, 0xd8, 0x64, 0x03, 0xea, 0x05, 0x77, 0xd3,
	0xdd, 0xc3, 0x32, 0x09, 0x3b, 0x33, 0x9d, 0x1d, 0x36, 0xfa, 0x06, 0xbe, 0x90, 0xef, 0xe2, 0xe3,
	0x34, 0x33, 0xcc, 0x02, 0xdd, 0x12, 0xd2, 0xbb, 0x39, 0xff, 0x39, 0xff, 0xf7, 0xef, 0xec, 0x19,
	0x68, 0xe6, 0x41, 0x77, 0x8c, 0x3a, 0xe7, 0x11, 0x52, 0xa5, 0xa5, 0x91, 0xa4, 0x9a, 0x07, 0xed,
	0xe3, 0x44, 0xca, 0x64, 0x8e, 0x5d, 0xa7, 0x5c, 0x2d, 0xa6, 0x5d, 0x4c, 0x95, 0xf9, 0xb3, 0x1c,
	0x68, 0x37, 0xac, 0x45, 0x31, 0xb1, 0x59, 0x1a, 0x66, 0x7c, 0x79, 0x98, 0x07, 0xdd, 0x41, 0x1a,
	0x2f, 0xab, 0xde, 0x17, 0xd8, 0xb7, 0xa3, 0xe4, 0x14, 0x0e, 0xc6, 0x28, 0x62, 0x77, 0x6e, 0xd2,
	0x3c, 0xa0, 0xa1, 0x3d, 0x5e, 0x62, 0x96, 0xb1, 0x04, 0xdb, 0x2d, 0xba, 0xcc, 0xa3, 0x45, 0x1e,
	0x1d, 0xda, 0xbc, 0xce, 0xde, 0x9b, 0x4a, 0x0f, 0xe1, 0x41, 0x3f, 0x41, 0x61, 0x48, 0x00, 0xcd,
	0x11, 0x5e, 0x2f, 0x30, 0x33, 0xae, 0xfe, 0x26, 0xa6, 0x92, 0x3c, 0x76, 0xa8, 0x55, 0xdd, 0xae,
	0xbb, 0x7a, 0x84, 0xd9, 0x62, 0x6e, 0x3a, 0x7b, 0xe4, 0x2d, 0xd4, 0x43, 0x2e, 0x92, 0x31, 0x66,
	0x19, 0x97, 0x82, 0x3c, 0x72, 0x5d, 0xab, 0xb4, 0xd7, 0x47, 0x1b, 0xf2, 0xae, 0xd2, 0xfb, 0x57,
	0x85, 0x83, 0x4b, 0x34, 0x2c, 0x66, 0x86, 0x91, 0x0f, 0x40, 0x7c, 0xd4, 0xf8, 0x7a, 0x6e, 0xd5,
	0x0b, 0xab, 0xfa, 0xef, 0x5e, 0x2b, 0xe5, 0xb8, 0xcf, 0xf0, 0x6c, 0x6d, 0xfb, 0xc9, 0xe3, 0x95,
	0xf3, 0x49, 0xe1, 0xdc, 0x10, 0xcb, 0xe6, 0x75, 0x66, 0x5f, 0xf1, 0x52, 0xe6, 0x86, 0xb2, 0x23,
	0xd3, 0x68, 0x2e, 0x92, 0x72, 0xe6, 0x2d, 0xb1, 0x6c, 0xee, 0xc3, 0x0b, 0x6f, 0x1e, 0xfe, 0x8e,
	0x50, 0x19, 0x2e, 0xc5, 0xca, 0xdf, 0x72, 0xa3, 0x77, 0xf4, 0x12, 0xa2, 0x37, 0x84, 0x7d, 0xbb,
	0x7c, 0x72, 0x06, 0x0d, 0xbb, 0x60, 0xb7, 0x0a, 0x27, 0xf8, 0xbf, 0x65, 0x98, 0xb9, 0xcf, 0x96,
	0xff, 0xd7, 0xa0, 0x15, 0x6a, 0x39, 0xe5, 0x73, 0xd4, 0x03, 0x99, 0xa6, 0x4c, 0xc4, 0xfe, 0x55,
	0x92, 0x4f, 0xd0, 0xf8, 0xca, 0x44, 0x3c, 0x47, 0xaf, 0x93, 0x23, 0x47, 0x1e, 0xa4, 0x71, 0x01,
	0x5e, 0x09, 0xfe, 0x32, 0x9d, 0xda, 0xdf, 0x6a, 0xc5, 0x6e, 0x95, 0x7c, 0x84, 0xa3, 0x5b, 0xde,
	0x5f, 0xbd, 0x7b, 0xb8, 0xdd, 0x83, 0x20, 0x67, 0x50, 0xf7, 0xa6, 0x61, 0x34, 0x93, 0xe4, 0x69,
	0x31, 0x65, 0xab, 0x11, 0x66, 0x4a, 0x8a, 0x6c, 0xc7, 0x95, 0xc8, 0x04, 0x5e, 0x16, 0xf7, 0x30,
	0x1a, 0x59, 0xda, 0x8f, 0x0c, 0xcf, 0xf1, 0xc7, 0x4c, 0x23, 0x8b, 0x07, 0x72, 0x21, 0x0c, 0x39,
	0x29, 0x88, 0x77, 0x5a, 0x23, 0xcc, 0x76, 0xfd, 0x2c, 0x12, 0xc2, 0x73, 0xcf, 0xde, 0xb4, 0x5e,
	0x2c, 0x52, 0x45, 0x8e, 0xb7, 0x41, 0x6d, 0x67, 0x27, 0x93, 0x4c, 0xe0, 0x64, 0x0b, 0xf1, 0x3b,
	0x4f, 0x66, 0xc6, 0x61, 0x5f, 0x6d, 0xc3, 0xae, 0xda, 0x3b, 0xd9, 0xe7, 0xa7, 0xf0, 0x3a, 0x92,
	0x29, 0x15, 0x2c, 0x47, 0x1d, 0x49, 0xad, 0xa8, 0xe2, 0x42, 0x49, 0x2e, 0x0c, 0x4d, 0xb4, 0x8a,
	0xa8, 0xd1, 0x2c, 0xc2, 0xf3, 0x43, 0xbf, 0xed, 0xd0, 0xba, 0xc3, 0xca, 0xa4, 0xd6, 0xcd, 0x83,
	0xab, 0x87, 0x8e, 0xf5, 0xfe, 0x26, 0x00, 0x00, 0xff, 0xff, 0xbf, 0xf1, 0xd1, 0xb2, 0xa4, 0x04,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SpanClient is the client API for Span service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SpanClient interface {
	SendSpan(ctx context.Context, opts ...grpc.CallOption) (Span_SendSpanClient, error)
}

type spanClient struct {
	cc *grpc.ClientConn
}

func NewSpanClient(cc *grpc.ClientConn) SpanClient {
	return &spanClient{cc}
}

func (c *spanClient) SendSpan(ctx context.Context, opts ...grpc.CallOption) (Span_SendSpanClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Span_serviceDesc.Streams[0], "/v1.Span/SendSpan", opts...)
	if err != nil {
		return nil, err
	}
	x := &spanSendSpanClient{stream}
	return x, nil
}

type Span_SendSpanClient interface {
	Send(*PSpanMessage) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type spanSendSpanClient struct {
	grpc.ClientStream
}

func (x *spanSendSpanClient) Send(m *PSpanMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *spanSendSpanClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SpanServer is the server API for Span service.
type SpanServer interface {
	SendSpan(Span_SendSpanServer) error
}

// UnimplementedSpanServer can be embedded to have forward compatible implementations.
type UnimplementedSpanServer struct {
}

func (*UnimplementedSpanServer) SendSpan(srv Span_SendSpanServer) error {
	return status.Errorf(codes.Unimplemented, "method SendSpan not implemented")
}

func RegisterSpanServer(s *grpc.Server, srv SpanServer) {
	s.RegisterService(&_Span_serviceDesc, srv)
}

func _Span_SendSpan_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SpanServer).SendSpan(&spanSendSpanServer{stream})
}

type Span_SendSpanServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*PSpanMessage, error)
	grpc.ServerStream
}

type spanSendSpanServer struct {
	grpc.ServerStream
}

func (x *spanSendSpanServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *spanSendSpanServer) Recv() (*PSpanMessage, error) {
	m := new(PSpanMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Span_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v1.Span",
	HandlerType: (*SpanServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendSpan",
			Handler:       _Span_SendSpan_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "v1/Service.proto",
}

// AgentClient is the client API for Agent service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AgentClient interface {
	RequestAgentInfo(ctx context.Context, in *PAgentInfo, opts ...grpc.CallOption) (*PResult, error)
	PingSession(ctx context.Context, opts ...grpc.CallOption) (Agent_PingSessionClient, error)
}

type agentClient struct {
	cc *grpc.ClientConn
}

func NewAgentClient(cc *grpc.ClientConn) AgentClient {
	return &agentClient{cc}
}

func (c *agentClient) RequestAgentInfo(ctx context.Context, in *PAgentInfo, opts ...grpc.CallOption) (*PResult, error) {
	out := new(PResult)
	err := c.cc.Invoke(ctx, "/v1.Agent/RequestAgentInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) PingSession(ctx context.Context, opts ...grpc.CallOption) (Agent_PingSessionClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Agent_serviceDesc.Streams[0], "/v1.Agent/PingSession", opts...)
	if err != nil {
		return nil, err
	}
	x := &agentPingSessionClient{stream}
	return x, nil
}

type Agent_PingSessionClient interface {
	Send(*PPing) error
	Recv() (*PPing, error)
	grpc.ClientStream
}

type agentPingSessionClient struct {
	grpc.ClientStream
}

func (x *agentPingSessionClient) Send(m *PPing) error {
	return x.ClientStream.SendMsg(m)
}

func (x *agentPingSessionClient) Recv() (*PPing, error) {
	m := new(PPing)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AgentServer is the server API for Agent service.
type AgentServer interface {
	RequestAgentInfo(context.Context, *PAgentInfo) (*PResult, error)
	PingSession(Agent_PingSessionServer) error
}

// UnimplementedAgentServer can be embedded to have forward compatible implementations.
type UnimplementedAgentServer struct {
}

func (*UnimplementedAgentServer) RequestAgentInfo(ctx context.Context, req *PAgentInfo) (*PResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestAgentInfo not implemented")
}
func (*UnimplementedAgentServer) PingSession(srv Agent_PingSessionServer) error {
	return status.Errorf(codes.Unimplemented, "method PingSession not implemented")
}

func RegisterAgentServer(s *grpc.Server, srv AgentServer) {
	s.RegisterService(&_Agent_serviceDesc, srv)
}

func _Agent_RequestAgentInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PAgentInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).RequestAgentInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Agent/RequestAgentInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).RequestAgentInfo(ctx, req.(*PAgentInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_PingSession_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AgentServer).PingSession(&agentPingSessionServer{stream})
}

type Agent_PingSessionServer interface {
	Send(*PPing) error
	Recv() (*PPing, error)
	grpc.ServerStream
}

type agentPingSessionServer struct {
	grpc.ServerStream
}

func (x *agentPingSessionServer) Send(m *PPing) error {
	return x.ServerStream.SendMsg(m)
}

func (x *agentPingSessionServer) Recv() (*PPing, error) {
	m := new(PPing)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Agent_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v1.Agent",
	HandlerType: (*AgentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RequestAgentInfo",
			Handler:    _Agent_RequestAgentInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PingSession",
			Handler:       _Agent_PingSession_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "v1/Service.proto",
}

// MetadataClient is the client API for Metadata service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MetadataClient interface {
	RequestSqlMetaData(ctx context.Context, in *PSqlMetaData, opts ...grpc.CallOption) (*PResult, error)
	RequestSqlUidMetaData(ctx context.Context, in *PSqlUidMetaData, opts ...grpc.CallOption) (*PResult, error)
	RequestApiMetaData(ctx context.Context, in *PApiMetaData, opts ...grpc.CallOption) (*PResult, error)
	RequestStringMetaData(ctx context.Context, in *PStringMetaData, opts ...grpc.CallOption) (*PResult, error)
	RequestExceptionMetaData(ctx context.Context, in *PExceptionMetaData, opts ...grpc.CallOption) (*PResult, error)
}

type metadataClient struct {
	cc *grpc.ClientConn
}

func NewMetadataClient(cc *grpc.ClientConn) MetadataClient {
	return &metadataClient{cc}
}

func (c *metadataClient) RequestSqlMetaData(ctx context.Context, in *PSqlMetaData, opts ...grpc.CallOption) (*PResult, error) {
	out := new(PResult)
	err := c.cc.Invoke(ctx, "/v1.Metadata/RequestSqlMetaData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metadataClient) RequestSqlUidMetaData(ctx context.Context, in *PSqlUidMetaData, opts ...grpc.CallOption) (*PResult, error) {
	out := new(PResult)
	err := c.cc.Invoke(ctx, "/v1.Metadata/RequestSqlUidMetaData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metadataClient) RequestApiMetaData(ctx context.Context, in *PApiMetaData, opts ...grpc.CallOption) (*PResult, error) {
	out := new(PResult)
	err := c.cc.Invoke(ctx, "/v1.Metadata/RequestApiMetaData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metadataClient) RequestStringMetaData(ctx context.Context, in *PStringMetaData, opts ...grpc.CallOption) (*PResult, error) {
	out := new(PResult)
	err := c.cc.Invoke(ctx, "/v1.Metadata/RequestStringMetaData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metadataClient) RequestExceptionMetaData(ctx context.Context, in *PExceptionMetaData, opts ...grpc.CallOption) (*PResult, error) {
	out := new(PResult)
	err := c.cc.Invoke(ctx, "/v1.Metadata/RequestExceptionMetaData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetadataServer is the server API for Metadata service.
type MetadataServer interface {
	RequestSqlMetaData(context.Context, *PSqlMetaData) (*PResult, error)
	RequestSqlUidMetaData(context.Context, *PSqlUidMetaData) (*PResult, error)
	RequestApiMetaData(context.Context, *PApiMetaData) (*PResult, error)
	RequestStringMetaData(context.Context, *PStringMetaData) (*PResult, error)
	RequestExceptionMetaData(context.Context, *PExceptionMetaData) (*PResult, error)
}

// UnimplementedMetadataServer can be embedded to have forward compatible implementations.
type UnimplementedMetadataServer struct {
}

func (*UnimplementedMetadataServer) RequestSqlMetaData(ctx context.Context, req *PSqlMetaData) (*PResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestSqlMetaData not implemented")
}
func (*UnimplementedMetadataServer) RequestSqlUidMetaData(ctx context.Context, req *PSqlUidMetaData) (*PResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestSqlUidMetaData not implemented")
}
func (*UnimplementedMetadataServer) RequestApiMetaData(ctx context.Context, req *PApiMetaData) (*PResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestApiMetaData not implemented")
}
func (*UnimplementedMetadataServer) RequestStringMetaData(ctx context.Context, req *PStringMetaData) (*PResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestStringMetaData not implemented")
}
func (*UnimplementedMetadataServer) RequestExceptionMetaData(ctx context.Context, req *PExceptionMetaData) (*PResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestExceptionMetaData not implemented")
}

func RegisterMetadataServer(s *grpc.Server, srv MetadataServer) {
	s.RegisterService(&_Metadata_serviceDesc, srv)
}

func _Metadata_RequestSqlMetaData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PSqlMetaData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataServer).RequestSqlMetaData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Metadata/RequestSqlMetaData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataServer).RequestSqlMetaData(ctx, req.(*PSqlMetaData))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metadata_RequestSqlUidMetaData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PSqlUidMetaData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataServer).RequestSqlUidMetaData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Metadata/RequestSqlUidMetaData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataServer).RequestSqlUidMetaData(ctx, req.(*PSqlUidMetaData))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metadata_RequestApiMetaData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PApiMetaData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataServer).RequestApiMetaData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Metadata/RequestApiMetaData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataServer).RequestApiMetaData(ctx, req.(*PApiMetaData))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metadata_RequestStringMetaData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PStringMetaData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataServer).RequestStringMetaData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Metadata/RequestStringMetaData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataServer).RequestStringMetaData(ctx, req.(*PStringMetaData))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metadata_RequestExceptionMetaData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PExceptionMetaData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataServer).RequestExceptionMetaData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Metadata/RequestExceptionMetaData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataServer).RequestExceptionMetaData(ctx, req.(*PExceptionMetaData))
	}
	return interceptor(ctx, in, info, handler)
}

var _Metadata_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v1.Metadata",
	HandlerType: (*MetadataServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RequestSqlMetaData",
			Handler:    _Metadata_RequestSqlMetaData_Handler,
		},
		{
			MethodName: "RequestSqlUidMetaData",
			Handler:    _Metadata_RequestSqlUidMetaData_Handler,
		},
		{
			MethodName: "RequestApiMetaData",
			Handler:    _Metadata_RequestApiMetaData_Handler,
		},
		{
			MethodName: "RequestStringMetaData",
			Handler:    _Metadata_RequestStringMetaData_Handler,
		},
		{
			MethodName: "RequestExceptionMetaData",
			Handler:    _Metadata_RequestExceptionMetaData_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/Service.proto",
}

// StatClient is the client API for Stat service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StatClient interface {
	SendAgentStat(ctx context.Context, opts ...grpc.CallOption) (Stat_SendAgentStatClient, error)
}

type statClient struct {
	cc *grpc.ClientConn
}

func NewStatClient(cc *grpc.ClientConn) StatClient {
	return &statClient{cc}
}

func (c *statClient) SendAgentStat(ctx context.Context, opts ...grpc.CallOption) (Stat_SendAgentStatClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Stat_serviceDesc.Streams[0], "/v1.Stat/SendAgentStat", opts...)
	if err != nil {
		return nil, err
	}
	x := &statSendAgentStatClient{stream}
	return x, nil
}

type Stat_SendAgentStatClient interface {
	Send(*PStatMessage) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type statSendAgentStatClient struct {
	grpc.ClientStream
}

func (x *statSendAgentStatClient) Send(m *PStatMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *statSendAgentStatClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StatServer is the server API for Stat service.
type StatServer interface {
	SendAgentStat(Stat_SendAgentStatServer) error
}

// UnimplementedStatServer can be embedded to have forward compatible implementations.
type UnimplementedStatServer struct {
}

func (*UnimplementedStatServer) SendAgentStat(srv Stat_SendAgentStatServer) error {
	return status.Errorf(codes.Unimplemented, "method SendAgentStat not implemented")
}

func RegisterStatServer(s *grpc.Server, srv StatServer) {
	s.RegisterService(&_Stat_serviceDesc, srv)
}

func _Stat_SendAgentStat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StatServer).SendAgentStat(&statSendAgentStatServer{stream})
}

type Stat_SendAgentStatServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*PStatMessage, error)
	grpc.ServerStream
}

type statSendAgentStatServer struct {
	grpc.ServerStream
}

func (x *statSendAgentStatServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *statSendAgentStatServer) Recv() (*PStatMessage, error) {
	m := new(PStatMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Stat_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v1.Stat",
	HandlerType: (*StatServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendAgentStat",
			Handler:       _Stat_SendAgentStat_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "v1/Service.proto",
}

// ProfilerCommandServiceClient is the client API for ProfilerCommandService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ProfilerCommandServiceClient interface {
	// deprecated api
	HandleCommand(ctx context.Context, opts ...grpc.CallOption) (ProfilerCommandService_HandleCommandClient, error)
	HandleCommandV2(ctx context.Context, opts ...grpc.CallOption) (ProfilerCommandService_HandleCommandV2Client, error)
	CommandEcho(ctx context.Context, in *PCmdEchoResponse, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CommandStreamActiveThreadCount(ctx context.Context, opts ...grpc.CallOption) (ProfilerCommandService_CommandStreamActiveThreadCountClient, error)
	CommandActiveThreadDump(ctx context.Context, in *PCmdActiveThreadDumpRes, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CommandActiveThreadLightDump(ctx context.Context, in *PCmdActiveThreadLightDumpRes, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type profilerCommandServiceClient struct {
	cc *grpc.ClientConn
}

func NewProfilerCommandServiceClient(cc *grpc.ClientConn) ProfilerCommandServiceClient {
	return &profilerCommandServiceClient{cc}
}

// Deprecated: Do not use.
func (c *profilerCommandServiceClient) HandleCommand(ctx context.Context, opts ...grpc.CallOption) (ProfilerCommandService_HandleCommandClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ProfilerCommandService_serviceDesc.Streams[0], "/v1.ProfilerCommandService/HandleCommand", opts...)
	if err != nil {
		return nil, err
	}
	x := &profilerCommandServiceHandleCommandClient{stream}
	return x, nil
}

type ProfilerCommandService_HandleCommandClient interface {
	Send(*PCmdMessage) error
	Recv() (*PCmdRequest, error)
	grpc.ClientStream
}

type profilerCommandServiceHandleCommandClient struct {
	grpc.ClientStream
}

func (x *profilerCommandServiceHandleCommandClient) Send(m *PCmdMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *profilerCommandServiceHandleCommandClient) Recv() (*PCmdRequest, error) {
	m := new(PCmdRequest)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *profilerCommandServiceClient) HandleCommandV2(ctx context.Context, opts ...grpc.CallOption) (ProfilerCommandService_HandleCommandV2Client, error) {
	stream, err := c.cc.NewStream(ctx, &_ProfilerCommandService_serviceDesc.Streams[1], "/v1.ProfilerCommandService/HandleCommandV2", opts...)
	if err != nil {
		return nil, err
	}
	x := &profilerCommandServiceHandleCommandV2Client{stream}
	return x, nil
}

type ProfilerCommandService_HandleCommandV2Client interface {
	Send(*PCmdMessage) error
	Recv() (*PCmdRequest, error)
	grpc.ClientStream
}

type profilerCommandServiceHandleCommandV2Client struct {
	grpc.ClientStream
}

func (x *profilerCommandServiceHandleCommandV2Client) Send(m *PCmdMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *profilerCommandServiceHandleCommandV2Client) Recv() (*PCmdRequest, error) {
	m := new(PCmdRequest)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *profilerCommandServiceClient) CommandEcho(ctx context.Context, in *PCmdEchoResponse, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/v1.ProfilerCommandService/CommandEcho", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *profilerCommandServiceClient) CommandStreamActiveThreadCount(ctx context.Context, opts ...grpc.CallOption) (ProfilerCommandService_CommandStreamActiveThreadCountClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ProfilerCommandService_serviceDesc.Streams[2], "/v1.ProfilerCommandService/CommandStreamActiveThreadCount", opts...)
	if err != nil {
		return nil, err
	}
	x := &profilerCommandServiceCommandStreamActiveThreadCountClient{stream}
	return x, nil
}

type ProfilerCommandService_CommandStreamActiveThreadCountClient interface {
	Send(*PCmdActiveThreadCountRes) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type profilerCommandServiceCommandStreamActiveThreadCountClient struct {
	grpc.ClientStream
}

func (x *profilerCommandServiceCommandStreamActiveThreadCountClient) Send(m *PCmdActiveThreadCountRes) error {
	return x.ClientStream.SendMsg(m)
}

func (x *profilerCommandServiceCommandStreamActiveThreadCountClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *profilerCommandServiceClient) CommandActiveThreadDump(ctx context.Context, in *PCmdActiveThreadDumpRes, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/v1.ProfilerCommandService/CommandActiveThreadDump", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *profilerCommandServiceClient) CommandActiveThreadLightDump(ctx context.Context, in *PCmdActiveThreadLightDumpRes, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/v1.ProfilerCommandService/CommandActiveThreadLightDump", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProfilerCommandServiceServer is the server API for ProfilerCommandService service.
type ProfilerCommandServiceServer interface {
	// deprecated api
	HandleCommand(ProfilerCommandService_HandleCommandServer) error
	HandleCommandV2(ProfilerCommandService_HandleCommandV2Server) error
	CommandEcho(context.Context, *PCmdEchoResponse) (*emptypb.Empty, error)
	CommandStreamActiveThreadCount(ProfilerCommandService_CommandStreamActiveThreadCountServer) error
	CommandActiveThreadDump(context.Context, *PCmdActiveThreadDumpRes) (*emptypb.Empty, error)
	CommandActiveThreadLightDump(context.Context, *PCmdActiveThreadLightDumpRes) (*emptypb.Empty, error)
}

// UnimplementedProfilerCommandServiceServer can be embedded to have forward compatible implementations.
type UnimplementedProfilerCommandServiceServer struct {
}

func (*UnimplementedProfilerCommandServiceServer) HandleCommand(srv ProfilerCommandService_HandleCommandServer) error {
	return status.Errorf(codes.Unimplemented, "method HandleCommand not implemented")
}
func (*UnimplementedProfilerCommandServiceServer) HandleCommandV2(srv ProfilerCommandService_HandleCommandV2Server) error {
	return status.Errorf(codes.Unimplemented, "method HandleCommandV2 not implemented")
}
func (*UnimplementedProfilerCommandServiceServer) CommandEcho(ctx context.Context, req *PCmdEchoResponse) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommandEcho not implemented")
}
func (*UnimplementedProfilerCommandServiceServer) CommandStreamActiveThreadCount(srv ProfilerCommandService_CommandStreamActiveThreadCountServer) error {
	return status.Errorf(codes.Unimplemented, "method CommandStreamActiveThreadCount not implemented")
}
func (*UnimplementedProfilerCommandServiceServer) CommandActiveThreadDump(ctx context.Context, req *PCmdActiveThreadDumpRes) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommandActiveThreadDump not implemented")
}
func (*UnimplementedProfilerCommandServiceServer) CommandActiveThreadLightDump(ctx context.Context, req *PCmdActiveThreadLightDumpRes) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommandActiveThreadLightDump not implemented")
}

func RegisterProfilerCommandServiceServer(s *grpc.Server, srv ProfilerCommandServiceServer) {
	s.RegisterService(&_ProfilerCommandService_serviceDesc, srv)
}

func _ProfilerCommandService_HandleCommand_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ProfilerCommandServiceServer).HandleCommand(&profilerCommandServiceHandleCommandServer{stream})
}

type ProfilerCommandService_HandleCommandServer interface {
	Send(*PCmdRequest) error
	Recv() (*PCmdMessage, error)
	grpc.ServerStream
}

type profilerCommandServiceHandleCommandServer struct {
	grpc.ServerStream
}

func (x *profilerCommandServiceHandleCommandServer) Send(m *PCmdRequest) error {
	return x.ServerStream.SendMsg(m)
}

func (x *profilerCommandServiceHandleCommandServer) Recv() (*PCmdMessage, error) {
	m := new(PCmdMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ProfilerCommandService_HandleCommandV2_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ProfilerCommandServiceServer).HandleCommandV2(&profilerCommandServiceHandleCommandV2Server{stream})
}

type ProfilerCommandService_HandleCommandV2Server interface {
	Send(*PCmdRequest) error
	Recv() (*PCmdMessage, error)
	grpc.ServerStream
}

type profilerCommandServiceHandleCommandV2Server struct {
	grpc.ServerStream
}

func (x *profilerCommandServiceHandleCommandV2Server) Send(m *PCmdRequest) error {
	return x.ServerStream.SendMsg(m)
}

func (x *profilerCommandServiceHandleCommandV2Server) Recv() (*PCmdMessage, error) {
	m := new(PCmdMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ProfilerCommandService_CommandEcho_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PCmdEchoResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProfilerCommandServiceServer).CommandEcho(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.ProfilerCommandService/CommandEcho",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProfilerCommandServiceServer).CommandEcho(ctx, req.(*PCmdEchoResponse))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProfilerCommandService_CommandStreamActiveThreadCount_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ProfilerCommandServiceServer).CommandStreamActiveThreadCount(&profilerCommandServiceCommandStreamActiveThreadCountServer{stream})
}

type ProfilerCommandService_CommandStreamActiveThreadCountServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*PCmdActiveThreadCountRes, error)
	grpc.ServerStream
}

type profilerCommandServiceCommandStreamActiveThreadCountServer struct {
	grpc.ServerStream
}

func (x *profilerCommandServiceCommandStreamActiveThreadCountServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *profilerCommandServiceCommandStreamActiveThreadCountServer) Recv() (*PCmdActiveThreadCountRes, error) {
	m := new(PCmdActiveThreadCountRes)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ProfilerCommandService_CommandActiveThreadDump_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PCmdActiveThreadDumpRes)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProfilerCommandServiceServer).CommandActiveThreadDump(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.ProfilerCommandService/CommandActiveThreadDump",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProfilerCommandServiceServer).CommandActiveThreadDump(ctx, req.(*PCmdActiveThreadDumpRes))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProfilerCommandService_CommandActiveThreadLightDump_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PCmdActiveThreadLightDumpRes)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProfilerCommandServiceServer).CommandActiveThreadLightDump(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.ProfilerCommandService/CommandActiveThreadLightDump",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProfilerCommandServiceServer).CommandActiveThreadLightDump(ctx, req.(*PCmdActiveThreadLightDumpRes))
	}
	return interceptor(ctx, in, info, handler)
}

var _ProfilerCommandService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v1.ProfilerCommandService",
	HandlerType: (*ProfilerCommandServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CommandEcho",
			Handler:    _ProfilerCommandService_CommandEcho_Handler,
		},
		{
			MethodName: "CommandActiveThreadDump",
			Handler:    _ProfilerCommandService_CommandActiveThreadDump_Handler,
		},
		{
			MethodName: "CommandActiveThreadLightDump",
			Handler:    _ProfilerCommandService_CommandActiveThreadLightDump_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "HandleCommand",
			Handler:       _ProfilerCommandService_HandleCommand_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "HandleCommandV2",
			Handler:       _ProfilerCommandService_HandleCommandV2_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "CommandStreamActiveThreadCount",
			Handler:       _ProfilerCommandService_CommandStreamActiveThreadCount_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "v1/Service.proto",
}
